****************************************************************
 [Untyped Lambda Interpreter]
                           R E A D M E
****************************************************************

Untyped Lambda Interpreterプログラムは，型システムの実験用に作ったλ計
算のインタプリタである．ただし，普通の関数型プログラミング言語っぽく使
えるように，純粋なλ計算にいくつかの拡張を施している．（レコード，組，
定数，など）

他に特徴的な拡張としては，メタプログラミングを可能にするための，
quote/unquo式がある．これはそれぞれLispのquoteとevalに相当する．


1.【起動方法と基本的な使い方】==================================

デフォルトでは対話型モードで起動する．起動メッセージとともにプロンプト
(>)が表示される．

実行例：
---
$ untyped
Untyped Lambda Interpreter, version 0.0.1
> 
---

コマンド起動時に，ファイル名を引数として与えると，起動時にそのファイル
がロードされた後に，プロンプトが表示される．
---
$ untyped util.prog
...省略...
Untyped Lambda Interpreter, version 0.0.1
> 

式を入力すると，インタプリタはそれを評価した結果を応答する．
---
> iadd_ 3 4;
===> 7
---

iadd_は整数の足し算を行うプリミティブ（デストラクタ）関数である．中置
記法はサポートしていないので，Lisp風に関数はすべて先頭におく．

関数適用は左結合なので，さきほどの例は以下と同じである．
---
> (iadd_ 3) 4;
===> 7
---

インタプリタを終了するには，exitプリミティブを使う．
---
> exit;
$
---

1.1.[大域変数の定義]

defコマンドを用いて大域変数を定義することもできる．
---
> def x = imul_ 2 3;
x = 6
> iadd_ x x;
===> 12
---

組(,で区切られた値)を使って同時に複数の値を定義することもできる．
---
> def v,w = 1,2;
v = 1
w = 2
> iadd_ v w;
===> 3
> def p3 = 1,true,"foo";
p3 = (1,true,"foo");
> def n,b,s = p3;
n = 1
b = true
s = "foo"
---

1.2.[λ式の表現]

λ式は（λ記号のかわりに\を用いて）以下のように表現する．
---
> \x.x;
===> (\x.x(0))
> (\x.iadd_ x x) 6;
===> 12
---
上は恒等関数λx.xの入力である．

# インタプリタの応答である\x.x(0)の0は変数xのDe Bruijinインデックスを
# 意味している．インタプリタの応答結果は適宜α変換がおこなわれるため，
# たとえば，xが大域変数として定義済みの場合，上記の応答は，(\x'.x'(0))
# となる．


たとえば，値を2倍にする関数doubleを定義するには，大域変数定義とλ抽象を組
み合わせて，以下のように入力すれば良い．
---
> def double = \x.iadd_ x x;
double = (\x.((iadd_ x(0)) x(0)))
> double(double 2);
===> 8
---

1.3.[遅延評価，ワイルドカード]

\\x.xのようにバックスラッシュを1つ余分につけたλ抽象の場合，xは遅延評
価（lazy evaluation/call by name）される．

以下のインタプリタの応答の違いに注目．
---
> (\x.\y.iadd_ x y)(imul_ 3 4);
===> (\y.((iadd_ 12) y(0)));
> (\\x.\y.iadd_ x y) (imul_ 3 4);
===> (\y.((iadd_ ((mul_ 3) 4)) y(0)))
---

遅延評価版の方は，引数が評価されずにそのまま置き換えられている．

# ところで，untypedインタプリタは置換（項書き換え）によって評価を行っ
# ているので，値としての関数が，その定義まで評価結果としてきちんと表示
# される．（通常のインタプリタ実装にあるような関数クロージャに相当する
# ものは無い）

\x.0のように変数xをλ抽象の本体中で使用しない場合は，\_.0のような
ワイルドカードの指定もできる．
---
> (\_.0) 123;
===> 0
---

1.4.[論理式，if式]

==, >, <, andalso, orなどの論理式，やif式はプリミティブではなく，
util.prog内でライブラリとして定義されている．

たとえば，if式は以下のように定義されている．
---
def if  = \b.\\t1.\\t2.
    case b of true  -> t1
            | false -> t2
            | ...   -> (\x.error "if: type mismatch");
---

1.4.[再帰関数の定義]

再帰関数は直接サポートしてないので，いわゆるYオペレータを定義してから
使う．これは，util.prog中にfixとして以下のように定義されている．

---
def fix   = \f.(\x.f (x x)) (\x.f (x x));
---

これを使って，たとえば階乗関数factは以下のように定義することができる．

---
> def fact  = fix (\\fact.\n.if (== n 0) 1 (imul_ n (fact (isub_ n 1))));
===> ...省略...
> fact 5;
===> 120
---

\\factのようにfact引数が遅延評価となっていることに注意．これを\factの
ように先行評価な引数としてしまうと，無限ループしてしまう．

# これを回避するにはfixを \f.(\x.f (\y.x x y)) (\x.f (\y.x x y))と定義
# してもよい．ただし，この場合のfixは関数にしか適用できなくなり，次に
# 説明する相互再帰が定義できない

相互再帰は，組を使って以下のように定義してやればよい．

---
> def even,odd =
    let evenodd =
      fix (\\eo.cons (\n.if (== n 0) true  (tl eo (isub_ n 1)))
                     (\n.if (== n 0) false (hd eo (isub_ n 1))))
    in 
      hd evenodd,tl evenodd;
===> ... 省略 ...
> even 5;
===> false
> odd 4;
===> true

1.5.[破壊的代入]

リファレンスセルを使うことで，命令言語っぽく破壊的代入ができる．refプ
リミティブで，リファレンスセルを生成し，!プリミティブでセルの値を参照
する．:=プリミティブでセルの内容を更新できる．

---
> def cell_r = ref 0;
cell_r = <0>
> !cell_r;
===> 0
> := cell_r (iadd_ (!cell_r) 1);
===> 1
> !cell_r;
===> 1
> cell_r;
<0>
---

上記のインタプリタの応答で，<0>は，確保されたメモリの（仮想的な）メモ
リアドレスを意味している．refを実行するたびに，メモリアドレスは増加す
る．

GCは未実装なので，refを使いまくると，いずれメモリが尽きるので注意が必
要である．


2.【Syntax】====================================================

あまり精確でない部分もあるが，だいたい以下のようなかんじ

2.1.[リテラル]
  - 整数      0, 5, 100とか
  - 小数      0.1, 1.0, 1234.567とか
  - 文字列    "hello,world\n"など

2.2.[識別子]
  - 非数字から始まる文字列
  - 記号文字からなる列

2.3.[コメント]
  - #から改行まではコメント
  - ブロックコメントはない

2.4.[式]

 t ::= c                  --- 定数（コンストラクタ／デストラクタ）
     | x                  --- 変数
     | \B.t               --- λ抽象（Bは変数の並び）
     | t t                --- λ適用
     | let B = t in t     --- let式
     | case t of c1 -> 11 | c2 -> 12 | ... | cn -> tn
                          --- case式
                          ---（最後のcn節は省略形式 ... -> En が使える）
     | t1,t2,...,tn       --- 組
     | { b1 = t1; b2 = t2; ... ; tn = tn }
                          --- レコード
     | t.l                --- ラベル参照
     | quote t            --- 引用（項を評価せずにそのままデータに変換）
     | unquo t            --- 逆引用（データを項として解釈）

 b ::= l | \l | _           --- l (∈ Label) 
 B ::= x | \x | _ | B,B |   --- x (∈ Variable)

2.5.[プログラム]

プログラムはセミコロンで終わるコマンド列．

 P ::= [ C ; ]*
 C ::= def B = t    --- 大域変数の定義
     | data c/n     --- アリティnのデータコンストラクタcの定義
     | t            --- 式の評価
     | use Ident    --- モジュールのインポート
     | ε            --- 空のコマンド


3.【Semantics】=================================================

以下は，λインタプリタのセマンティクスの（いい加減な）形式的定義である．

3.1.[評価文脈の定義]

まず，値は以下の形をした式（項）である．

 v ::= <m>           (m∈Address)  --- セルのアドレス
     | \b1,...,bn.E                --- λ抽象
     | c v1 ... vk   (k ≦ n)      --- cはアリティnのコンストラクタ
     | d v1 ... vk   (k ＜ n)      --- dはアリティnのデストラクタ
     | v1,...,vn                   --- 組
     | { r1; ...; rn }             --- レコード

 b ::= x | \x | _ 
 r ::= x = v | _ = v | \x = t 

評価文脈E,R,Tは以下のように穴[]のある項である．

 E ::= []
     | E t | (\x.t) E | (\_.t) E
     | (\b1,...,bn.t) T   (n>1)
     | case E of c1 -> t1 | ... | cn -> tn
     | (v1,…,Ei,…,tn)
     | { r1; ...; Ri; ...; bn=tn }
     | unquo E
 R ::= x = E | _ = E | \x = t
 T ::= []
     | E t | (\x.t) E | (\_.t) E
     | (\b1,...,bn.t) T   (n>1)
     | case E of c1 -> t1 | … | ... -> t
     | { r1; ...; Ri; ...; bn=tn }
     | unquo E

# 評価文脈Tはλ適用におけるλ抽象の引数が複数ある場合，組の内側まで評
# 価を進めないようにする気持ちを込めている．

3.2.[変換規則]

<let式の展開>

let式は評価時に以下のように展開される

   let b1,…,bn = t1 in t2 ⇒ (\b1,…,bn.t2) t1

<組適用の変換>

組に対するλ適用は，以下のように展開される．

   (\b1,…,bn.t) (t1,…,tn) ⇒ ((…(((\b1.(\b2.(….(\bn.t)…))) t1) t2)…) tn)

<β簡約>

 (\_.t) v → v
 (\x.t) v → t[x:=v]
 (\\x.t) t' → t[x:=t']

<δ簡約>

  d v1 ... vn → δd(v1,....,vn)      (dはアリティn)
                                  --- δはプリミティブごとに定義される

<case簡約>

--- c==ciのとき
  case c v1...vn of c1 -> t1
                 |  c2 -> t2
                 | ...
                 |  cn -> tn    → ti v1...vn

--- c≠ciのとき
  case c v1...vn of c1 -> t1
                 |  c2 -> t2
                 | ...
                 |  cn -> tn
                 | ... -> t     → t c v1...vn

<label簡約>

  { b1 = t1; ...; bn = tn} . li → ti   (ただし，liとbiのラベル名が等しい)


<quote簡約>

  quote t → <項tのデータ表現>

<unquo簡約>

  unquo v → <データvの項表現>

4.【メタプログラミング】========================================

λインタプリタでは，quote/unquo式を使ったメタプログラミングが可能である．

quote t式は，式tを評価せずに，コンストラクタを用いたλインタプリタが扱
える対象としてのデータ構造に変換する．

---
> quote (iadd_ 3 4);
===> (tm_app
        (tm_app
            (tm_con (cn_sym "iadd_") nil)
            (tm_con (cn_int 3) nil))
        (tm_con (cn_int 4) nil))
---
# 適当に改行を入れて見やすくしている．

ここで，tm_appやtm_conはλインタプリタの抽象構文木に相当するコンストラ
クタである．

unquo t式は，式tを評価した結果としてのデータ構造を，インタプリタ内部の
抽象構文木に戻して評価を続ける．Lispでいうところのevalに相当する．

---
> unquo (quote (iadd_ 3 4));
===> 7
---

直接構文木に対応するデータ構造を入力して，unquoすることもできる．

---
> unquo(tm_app
          (tm_app
            (tm_con (cn_sym "iadd_") nil)
            (tm_con (cn_int 3) nil))
          (tm_con (cn_int 4) nil));
===> 7
---

サンプルプログラムtyping.progは，メタプログラミング機能を使って，単純
型付きλ計算の型推論を実装したものである．

---
$ untyped typing.prog
...省略...
Untyped Lambda Interpreter, version 0.0.1
> type 0;
===> "int"
> type (iadd_ 1 2);
===> "int"
> type (\x.x);
===> "t<0>->t<0>"
---


4.1.[抽象構文木のデータ構造]

 T.B.D. ソースコードの absyn.ml, meta.ml を参照されたい．


5. 【プリミティブ一覧】=========================================

基本的には，prims.mlで定義されている．拡張したい場合，このソースファイ
ルに追加していけばよい．

5.1.[コンストラクタ]

 - nil/0
 - cons/2
 - true/0
 - false/0

5.2.[デストラクタ]

 - iadd_ x y    : 整数x,yの和(x+y)
 - isub_ x y    : 整数x,yの差(x-y)
 - imul_ x y    : 整数x,yの積(x*y)
 - idiv_ x y    : 整数x,yの整除(x/y)
 - imod_ x y    : 整数x,yの剰余(x mod y)
 - itos_ x      : 整数xを文字列に変換
 - mtos_ m      : リファレンスセルmを文字列に変換
 - scat_ s t    : 文字列s,tの連結
 - outs_ s      : 文字列sを表示する
 - igt_ n m x y : 整数値の比較．n>mならx，そうでなければ，yを返す
 - ref_ x       : xを内容としたリファレンスセルを生成
 - ! m          : mの内容を参照
 - := m x       : mの内容をxに更新
 - beq v w x y  : 等価比較．v = wならx，そうでなければ，yを返す
 - exit         : インタプリタを終了する
 - error s      : 式の評価を中止し，メッセージsを出力する．
